"""
Effect processing and world state updates for the battle demo.

This module handles the processing of effects generated by the combat system,
updating the world state and managing game status including win conditions.
"""

from typing import Any

from gunn.utils.telemetry import get_logger

from ..shared.enums import AgentStatus, WeaponCondition
from ..shared.models import BattleWorldState, TeamCommunication


class EffectProcessor:
    """Processes effects and updates world state accordingly."""

    def __init__(self, action_callback=None, broadcast_callback=None):
        """Initialize the effect processor.

        Args:
            action_callback: Optional callback function to notify about action results.
                             Signature: async def callback(agent_id, action_type, success, details)
            broadcast_callback: Optional callback function for WebSocket broadcasting.
                                Signature: async def callback(team, payload)
        """
        self._logger = get_logger("effect_processor")
        self._action_callback = action_callback
        self._broadcast_callback = broadcast_callback

        # Map effect kinds to their handler methods
        self._effect_handlers = {
            "AgentDamaged": self._handle_agent_damaged,
            "AgentDied": self._handle_agent_died,
            "WeaponDegraded": self._handle_weapon_degraded,
            "AgentHealed": self._handle_agent_healed,
            "WeaponRepaired": self._handle_weapon_repaired,
            "TeamMessage": self._handle_team_message,
            "Speak": self._handle_speak_effect,
            "Move": self._handle_agent_move,
            "Attack": self._handle_attack_effect,
            "AttackFailed": self._handle_attack_failed,
            "HealFailed": self._handle_heal_failed,
            "RepairFailed": self._handle_repair_failed,
            "CommunicationFailed": self._handle_communication_failed,
        }

    async def process_effects(
        self, effects: list[dict[str, Any]], world_state: BattleWorldState
    ) -> dict[str, Any]:
        """
        Process a list of effects and update the world state.

        Args:
            effects: List of effect dictionaries to process
            world_state: Current world state to update

        Returns:
            Dictionary containing processing results and statistics
        """
        processed_count = 0
        failed_count = 0
        effect_types = {}

        for effect in effects:
            try:
                effect_kind = effect.get("kind", "Unknown")

                # Track effect type statistics
                effect_types[effect_kind] = effect_types.get(effect_kind, 0) + 1

                # Process the effect
                await self._process_single_effect(effect, world_state)
                processed_count += 1

                self._logger.debug(f"Processed effect: {effect_kind}")

                # Notify about action results
                await self._notify_action_result(effect, world_state)

            except Exception as e:
                failed_count += 1
                self._logger.error(f"Failed to process effect {effect}: {e}")

        # Update game status after processing all effects
        old_status = world_state.game_status
        world_state.update_game_status()

        # Log status change if it occurred
        if world_state.game_status != old_status:
            self._logger.info(
                f"Game status changed from {old_status} to {world_state.game_status}"
            )

        return {
            "processed_count": processed_count,
            "failed_count": failed_count,
            "effect_types": effect_types,
            "game_status": world_state.game_status,
            "status_changed": world_state.game_status != old_status,
            "communication_stats": self._get_communication_stats(world_state),
        }

    async def _process_single_effect(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Process a single effect using the appropriate handler.

        Args:
            effect: Effect dictionary to process
            world_state: World state to update
        """
        effect_kind = effect.get("kind", "Unknown")
        handler = self._effect_handlers.get(effect_kind)

        if handler:
            await handler(effect, world_state)
            # Notify about action results after processing effect
            await self._notify_action_result(effect, world_state)
        else:
            self._logger.warning(f"No handler found for effect kind: {effect_kind}")

    async def _notify_action_result(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """Notify about action results via callback."""
        if not self._action_callback:
            return

        try:
            effect_kind = effect.get("kind", "")
            payload = effect.get("payload", {})
            source_id = effect.get("source_id", "")

            # Map effect kinds to action types and extract details
            action_mapping = {
                "Move": ("move", True, ""),
                "Attack": ("attack", True, "attacking"),
                "AgentDamaged": ("attack", True, f"-{payload.get('damage', 0)}HP"),
                "AgentDied": ("kill", True, "eliminated"),
                "AgentHealed": ("heal", True, f"+{payload.get('heal_amount', 0)}HP"),
                "WeaponRepaired": ("repair", True, "weapon fixed"),
                "TeamMessage": ("communicate", True, ""),
                "AttackFailed": ("attack", False, payload.get("reason", "failed")),
                "HealFailed": ("heal", False, payload.get("reason", "failed")),
                "RepairFailed": ("repair", False, payload.get("reason", "failed")),
            }

            if effect_kind in action_mapping:
                action_type, success, details = action_mapping[effect_kind]
                await self._action_callback(source_id, action_type, success, details)

        except Exception as e:
            self._logger.warning(f"Error notifying action result: {e}")

    async def _handle_agent_damaged(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle AgentDamaged effect by updating agent health.

        Args:
            effect: AgentDamaged effect
            world_state: World state to update

        Raises:
            ValueError: If effect payload is invalid
        """
        payload = effect.get("payload", {})
        target_id = payload.get("target_id")
        new_health = payload.get("new_health")

        if not target_id or new_health is None:
            self._logger.error(f"Invalid AgentDamaged effect payload: {payload}")
            raise ValueError(f"Invalid AgentDamaged effect payload: {payload}")

        agent = world_state.agents.get(target_id)
        if not agent:
            self._logger.error(f"Agent {target_id} not found for damage effect")
            raise ValueError(f"Agent {target_id} not found for damage effect")

        # Update agent health
        old_health = agent.health
        agent.health = max(0, int(new_health))

        self._logger.info(
            f"Agent {target_id} damaged: {old_health} -> {agent.health} HP"
        )

        # If health reaches 0, agent should be marked as dead
        if agent.health == 0 and agent.status == AgentStatus.ALIVE:
            agent.status = AgentStatus.DEAD
            self._logger.info(f"Agent {target_id} died from damage")

    async def _handle_agent_died(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle AgentDied effect by marking agent as dead.

        Args:
            effect: AgentDied effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        agent_id = payload.get("agent_id")
        killer_id = payload.get("killer_id")

        if not agent_id:
            self._logger.error(f"Invalid AgentDied effect payload: {payload}")
            raise ValueError(f"Invalid AgentDied effect payload: {payload}")

        agent = world_state.agents.get(agent_id)
        if not agent:
            self._logger.error(f"Agent {agent_id} not found for death effect")
            raise ValueError(f"Agent {agent_id} not found for death effect")

        # Mark agent as dead
        agent.status = AgentStatus.DEAD
        agent.health = 0

        # Update team scores (killer's team gets a point)
        if killer_id:
            killer = world_state.agents.get(killer_id)
            if killer:
                world_state.team_scores[killer.team] += 1
                self._logger.info(
                    f"Agent {agent_id} killed by {killer_id}. "
                    f"Team {killer.team} score: {world_state.team_scores[killer.team]}"
                )
            else:
                self._logger.warning(f"Killer {killer_id} not found")

        self._logger.info(f"Agent {agent_id} marked as dead")

    async def _handle_weapon_degraded(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle WeaponDegraded effect by updating weapon condition.

        Args:
            effect: WeaponDegraded effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        agent_id = payload.get("agent_id")
        new_condition = payload.get("new_condition")

        if not agent_id or not new_condition:
            self._logger.error(f"Invalid WeaponDegraded effect payload: {payload}")
            return

        agent = world_state.agents.get(agent_id)
        if not agent:
            self._logger.error(f"Agent {agent_id} not found for weapon degradation")
            return

        # Update weapon condition
        try:
            old_condition = agent.weapon_condition
            agent.weapon_condition = WeaponCondition(new_condition)

            self._logger.info(
                f"Agent {agent_id} weapon degraded: {old_condition.value} -> {new_condition}"
            )
        except ValueError:
            self._logger.error(f"Invalid weapon condition: {new_condition}")

    async def _handle_agent_healed(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle AgentHealed effect by updating agent health.

        Args:
            effect: AgentHealed effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        target_id = payload.get("target_id")
        new_health = payload.get("new_health")

        if not target_id or new_health is None:
            self._logger.error(f"Invalid AgentHealed effect payload: {payload}")
            return

        agent = world_state.agents.get(target_id)
        if not agent:
            self._logger.error(f"Agent {target_id} not found for heal effect")
            return

        # Update agent health
        old_health = agent.health
        agent.health = min(100, max(0, int(new_health)))

        self._logger.info(
            f"Agent {target_id} healed: {old_health} -> {agent.health} HP"
        )

    async def _handle_weapon_repaired(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle WeaponRepaired effect by updating weapon condition.

        Args:
            effect: WeaponRepaired effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        agent_id = payload.get("agent_id")
        new_condition = payload.get("new_condition")

        if not agent_id or not new_condition:
            self._logger.error(f"Invalid WeaponRepaired effect payload: {payload}")
            return

        agent = world_state.agents.get(agent_id)
        if not agent:
            self._logger.error(f"Agent {agent_id} not found for weapon repair")
            return

        # Update weapon condition
        try:
            old_condition = agent.weapon_condition
            agent.weapon_condition = WeaponCondition(new_condition)

            self._logger.info(
                f"Agent {agent_id} weapon repaired: {old_condition.value} -> {new_condition}"
            )
        except ValueError:
            self._logger.error(f"Invalid weapon condition: {new_condition}")

    async def _handle_team_message(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle TeamMessage effect by adding message to team communications.

        This implements team-only visibility with urgency-based prioritization.
        Messages are only stored for the sender's team and are not visible to enemies.

        Args:
            effect: TeamMessage effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        sender_id = payload.get("sender_id")
        sender_team = payload.get("sender_team")
        message = payload.get("message")
        urgency = payload.get("urgency", "medium")
        timestamp = payload.get("timestamp", world_state.game_time)

        if not sender_id or not sender_team or not message:
            self._logger.error(f"Invalid TeamMessage effect payload: {payload}")
            return

        # Verify sender exists and team matches
        sender = world_state.agents.get(sender_id)
        if not sender:
            self._logger.error(f"Sender {sender_id} not found for team message")
            return

        if sender.team != sender_team:
            self._logger.error(f"Sender team mismatch: {sender.team} != {sender_team}")
            return

        # Validate urgency level
        valid_urgencies = ["low", "medium", "high"]
        if urgency not in valid_urgencies:
            self._logger.warning(f"Invalid urgency '{urgency}', defaulting to 'medium'")
            urgency = "medium"

        # Create team communication
        try:
            team_comm = TeamCommunication(
                sender_id=sender_id,
                team=sender_team,
                message=message,
                urgency=urgency,
                timestamp=timestamp,
            )

            # Add to team communications (team-only visibility)
            world_state.team_communications[sender_team].append(team_comm)

            # Keep only last 50 messages per team to prevent memory bloat
            if len(world_state.team_communications[sender_team]) > 50:
                world_state.team_communications[sender_team] = (
                    world_state.team_communications[sender_team][-50:]
                )

            # Log with urgency indicator
            urgency_indicator = (
                "!" if urgency == "high" else "?" if urgency == "medium" else ""
            )
            self._logger.info(
                f"Team message [{urgency.upper()}{urgency_indicator}] from {sender_id} to {sender_team}: {message[:50]}..."
            )

        except Exception as e:
            self._logger.error(f"Failed to create team communication: {e}")

    async def _handle_speak_effect(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """Handle Speak effect by broadcasting to WebSocket clients.

        Speak effects are Gunn's built-in communication mechanism. This handler
        converts them to team communications and broadcasts via WebSocket.

        Args:
            effect: Speak effect from Gunn orchestrator
            world_state: World state to update
        """
        sender_id = effect.get("source_id")
        payload = effect.get("payload", {})

        self._logger.info(
            f"[COMM] Handling Speak effect: sender={sender_id}, "
            f"message={payload.get('message', '')[:50]}"
        )

        if not sender_id or sender_id not in world_state.agents:
            self._logger.warning(f"[COMM] Speak effect has invalid sender: {sender_id}")
            return

        sender_agent = world_state.agents[sender_id]
        sender_team = sender_agent.team

        # Convert Speak effect to team communication format
        comm_payload = {
            "sender_id": sender_id,
            "sender_team": sender_team,
            "message": payload.get("message", ""),
            "urgency": payload.get("urgency", "medium"),
            "timestamp": world_state.game_time,
        }

        # Broadcast via WebSocket callback if available
        if self._broadcast_callback:
            try:
                self._logger.info(
                    f"[COMM] Broadcasting Speak as team communication: {comm_payload}"
                )
                await self._broadcast_callback(sender_team, comm_payload)
            except Exception as e:
                self._logger.error(f"[COMM] Failed to broadcast Speak effect: {e}")
        else:
            self._logger.warning(
                "[COMM] No broadcast callback registered, Speak effect not broadcast"
            )

    async def _handle_agent_move(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle Move effect by updating agent position.

        Args:
            effect: Move effect
            world_state: World state to update
        """
        payload = effect.get("payload", {})
        agent_id = effect.get("source_id") or payload.get("agent_id")
        new_position = payload.get("new_position") or payload.get("target_position")

        if not agent_id or not new_position:
            self._logger.error(f"Invalid Move effect payload: {payload}")
            return

        agent = world_state.agents.get(agent_id)
        if not agent:
            self._logger.error(f"Agent {agent_id} not found for move effect")
            return

        # Update agent position
        old_position = agent.position
        agent.position = tuple(new_position[:2])  # Ensure 2D position

        self._logger.debug(
            f"Agent {agent_id} moved: {old_position} -> {agent.position}"
        )

    async def _handle_attack_effect(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle Attack effect by processing it through BattleActionProcessor.

        Args:
            effect: Attack effect
            world_state: Current world state

        Returns:
            List of resulting effects (AgentDamaged, AgentDied, etc.)
        """
        from .battle_mechanics import CombatManager

        payload = effect.get("payload", {})
        attacker_id = payload.get("attacker_id")
        target_id = payload.get("target_id")

        self._logger.info(
            f"[ATTACK] Processing Attack effect: attacker={attacker_id}, target={target_id}"
        )

        if not attacker_id or not target_id:
            self._logger.warning(
                f"Attack effect missing attacker_id or target_id: {payload}"
            )
            return

        # Process attack through battle mechanics
        combat_manager = CombatManager()
        resulting_effects = await combat_manager.process_attack(
            attacker_id, target_id, world_state
        )

        self._logger.info(
            f"[ATTACK] Generated {len(resulting_effects)} resulting effects: "
            f"{[e.get('kind') for e in resulting_effects]}"
        )

        # Process resulting effects (AgentDamaged, AgentDied, etc.)
        for resulting_effect in resulting_effects:
            effect_kind = resulting_effect.get("kind")
            handler = self._effect_handlers.get(effect_kind)
            if handler:
                await handler(resulting_effect, world_state)
            else:
                self._logger.warning(f"No handler for effect kind: {effect_kind}")

        self._logger.debug(
            f"Processed Attack effect: attacker={attacker_id}, target={target_id}, "
            f"resulting_effects={len(resulting_effects)}"
        )

    async def _handle_attack_failed(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle AttackFailed effect (logging only, no state changes).

        Args:
            effect: AttackFailed effect
            world_state: World state (not modified)
        """
        payload = effect.get("payload", {})
        attacker_id = payload.get("attacker_id")
        reason = payload.get("reason", "unknown")

        self._logger.debug(f"Attack failed for {attacker_id}: {reason}")

    async def _handle_heal_failed(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle HealFailed effect (logging only, no state changes).

        Args:
            effect: HealFailed effect
            world_state: World state (not modified)
        """
        payload = effect.get("payload", {})
        healer_id = payload.get("healer_id")
        reason = payload.get("reason", "unknown")

        self._logger.debug(f"Heal failed for {healer_id}: {reason}")

    async def _handle_repair_failed(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle RepairFailed effect (logging only, no state changes).

        Args:
            effect: RepairFailed effect
            world_state: World state (not modified)
        """
        payload = effect.get("payload", {})
        agent_id = payload.get("agent_id")
        reason = payload.get("reason", "unknown")

        self._logger.debug(f"Repair failed for {agent_id}: {reason}")

    async def _handle_communication_failed(
        self, effect: dict[str, Any], world_state: BattleWorldState
    ) -> None:
        """
        Handle CommunicationFailed effect (logging only, no state changes).

        Args:
            effect: CommunicationFailed effect
            world_state: World state (not modified)
        """
        payload = effect.get("payload", {})
        sender_id = payload.get("sender_id")
        reason = payload.get("reason", "unknown")

        self._logger.debug(f"Communication failed for {sender_id}: {reason}")

    def _get_communication_stats(self, world_state: BattleWorldState) -> dict[str, Any]:
        """Get communication statistics for monitoring.

        Args:
            world_state: Current world state

        Returns:
            Dictionary containing communication statistics
        """
        stats = {
            "total_messages": 0,
            "messages_by_team": {},
            "messages_by_urgency": {"high": 0, "medium": 0, "low": 0},
            "recent_activity": {"team_a": 0, "team_b": 0},
        }

        current_time = world_state.game_time
        recent_threshold = 30.0  # Last 30 seconds

        for team, messages in world_state.team_communications.items():
            team_count = len(messages)
            stats["total_messages"] += team_count
            stats["messages_by_team"][team] = team_count

            # Count recent messages (last 30 seconds)
            recent_count = sum(
                1
                for msg in messages
                if current_time - msg.timestamp <= recent_threshold
            )
            stats["recent_activity"][team] = recent_count

            # Count by urgency
            for msg in messages:
                urgency = msg.urgency
                if urgency in stats["messages_by_urgency"]:
                    stats["messages_by_urgency"][urgency] += 1

        return stats


class GameStatusManager:
    """Manages game status and win condition detection."""

    def __init__(self):
        """Initialize the game status manager."""
        self._logger = get_logger("game_status_manager")

    def check_win_condition(self, world_state: BattleWorldState) -> str:
        """
        Check current win condition based on alive agents.

        Args:
            world_state: Current world state

        Returns:
            Game status: "active", "team_a_wins", "team_b_wins", or "draw"
        """
        team_a_alive = len(world_state.get_alive_agents("team_a"))
        team_b_alive = len(world_state.get_alive_agents("team_b"))

        if team_a_alive == 0 and team_b_alive == 0:
            return "draw"
        elif team_a_alive == 0:
            return "team_b_wins"
        elif team_b_alive == 0:
            return "team_a_wins"
        else:
            return "active"

    def update_game_status(self, world_state: BattleWorldState) -> bool:
        """
        Update game status based on current conditions.

        Args:
            world_state: World state to update

        Returns:
            True if status changed, False otherwise
        """
        old_status = world_state.game_status
        new_status = self.check_win_condition(world_state)

        if old_status != new_status:
            world_state.game_status = new_status
            self._logger.info(f"Game status changed: {old_status} -> {new_status}")

            # Log final scores when game ends
            if new_status != "active":
                team_a_score = world_state.team_scores.get("team_a", 0)
                team_b_score = world_state.team_scores.get("team_b", 0)
                self._logger.info(
                    f"Final scores - Team A: {team_a_score}, Team B: {team_b_score}"
                )

            return True

        return False

    def get_game_statistics(self, world_state: BattleWorldState) -> dict[str, Any]:
        """
        Get comprehensive game statistics.

        Args:
            world_state: Current world state

        Returns:
            Dictionary containing game statistics
        """
        team_a_agents = world_state.get_team_agents("team_a")
        team_b_agents = world_state.get_team_agents("team_b")

        team_a_alive = len(world_state.get_alive_agents("team_a"))
        team_b_alive = len(world_state.get_alive_agents("team_b"))

        # Calculate team health totals
        team_a_health = sum(agent.health for agent in team_a_agents.values())
        team_b_health = sum(agent.health for agent in team_b_agents.values())

        # Count weapon conditions
        weapon_stats = {"team_a": {}, "team_b": {}}
        for team, agents in [("team_a", team_a_agents), ("team_b", team_b_agents)]:
            for condition in WeaponCondition:
                count = sum(
                    1
                    for agent in agents.values()
                    if agent.weapon_condition == condition
                )
                weapon_stats[team][condition.value] = count

        return {
            "game_status": world_state.game_status,
            "game_time": world_state.game_time,
            "team_scores": world_state.team_scores.copy(),
            "agents_alive": {
                "team_a": team_a_alive,
                "team_b": team_b_alive,
                "total": team_a_alive + team_b_alive,
            },
            "team_health": {"team_a": team_a_health, "team_b": team_b_health},
            "weapon_conditions": weapon_stats,
            "total_agents": {
                "team_a": len(team_a_agents),
                "team_b": len(team_b_agents),
            },
            "communication_counts": {
                "team_a": len(world_state.team_communications.get("team_a", [])),
                "team_b": len(world_state.team_communications.get("team_b", [])),
            },
        }
